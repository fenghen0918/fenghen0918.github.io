<!DOCTYPE HTML>
<html lang="zh-CN">




<head>
    <meta charset="utf-8">
    <meta name="keywords" content="微服务（SpringCloud、SpringCloudAlibaba）, Java,Linux,Mysql,Oracle">
    <meta name="description" content="专注业务，专注代码,分享生活,分享知识">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>微服务（SpringCloud、SpringCloudAlibaba） | 特仑苏</title>
    <link rel="icon" type="image/png" href="/medias/favicon.png">

    <link rel="stylesheet" type="text/css" href="https://fastly.jsdelivr.net/gh/fenghen0918/fenghen0918.github.io/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="https://fastly.jsdelivr.net/gh/fenghen0918/fenghen0918.github.io/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://fastly.jsdelivr.net/gh/fenghen0918/fenghen0918.github.io/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="https://fastly.jsdelivr.net/gh/fenghen0918/fenghen0918.github.io/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://fastly.jsdelivr.net/gh/fenghen0918/fenghen0918.github.io/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="https://fastly.jsdelivr.net/gh/fenghen0918/fenghen0918.github.io/css/matery.css">
    <link rel="stylesheet" type="text/css" href="https://fastly.jsdelivr.net/gh/fenghen0918/fenghen0918.github.io/css/my.css">

    <script src="https://fastly.jsdelivr.net/gh/fenghen0918/fenghen0918.github.io/libs/jquery/jquery.min.js"></script>

    <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>

    <!-- <script src="https://v1.hitokoto.cn/?c=d&encode=js&select=%23hitokoto" defer></script> -->



    <link type='text/css' rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" media='all'/>
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.13.1/css/all.min.css" rel="stylesheet">

<meta name="generator" content="Hexo 6.0.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>



 <div id="loading-container">
     <p class="loading-text">玩命加载中 . . . </p> 
     <div class="loading-image">
         <div></div>
         <div></div>
         <div></div>
         <div></div> 
         <div></div>
     </div>
 </div><body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/sulog.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">特仑苏</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fas fa-book" style="zoom: 0.6;"></i>
      
      <span>文章</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/tags">
          
          <i class="fas fa-tags" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>标签</span>
        </a>
      </li>
      
      <li>
        <a href="/categories">
          
          <i class="fas fa-bookmark" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>分类</span>
        </a>
      </li>
      
      <li>
        <a href="/archives">
          
          <i class="fas fa-archive" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>归档</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于我</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/artitalk" class="waves-effect waves-light">
      
      <i class="fas fa-comment" style="zoom: 0.6;"></i>
      
      <span>特仑说</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留个言</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-rainbow" style="zoom: 0.6;"></i>
      
      <span>友人帐</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/galleries" class="waves-effect waves-light">
      
      <i class="fas fa-image" style="zoom: 0.6;"></i>
      
      <span>相册</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fas fa-bicycle" style="zoom: 0.6;"></i>
      
      <span>爱好</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/bangumis">
          
          <i class="fas fa-play-circle" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>追番</span>
        </a>
      </li>
      
      <li>
        <a href="/musics">
          
          <i class="fas fa-music" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>音乐</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
    <a onclick="switchNightMode()" id="sma" title="模式切换" class="waves-effect waves-light">
      <i class="fa fa-moon-o" id="nightMode" aria-hidden="true"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/sulog.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">特仑苏</div>
        <div class="logo-desc">
            
            专注业务，专注代码,分享生活,分享知识
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-book"></i>
			
			文章
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>

                  <a href="/tags " style="margin-left:75px">
				  
				   <i class="fa fas fa-tags" style="position: absolute;left:50px" ></i>
			      
		          <span>标签</span>
                  </a>
                </li>
              
                <li>

                  <a href="/categories " style="margin-left:75px">
				  
				   <i class="fa fas fa-bookmark" style="position: absolute;left:50px" ></i>
			      
		          <span>分类</span>
                  </a>
                </li>
              
                <li>

                  <a href="/archives " style="margin-left:75px">
				  
				   <i class="fa fas fa-archive" style="position: absolute;left:50px" ></i>
			      
		          <span>归档</span>
                  </a>
                </li>
              
            </ul>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/artitalk" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comment"></i>
			
			特仑说
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-rainbow"></i>
			
			友情链接
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/galleries" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-image"></i>
			
			相册
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-bicycle"></i>
			
			爱好
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>

                  <a href="/bangumis " style="margin-left:75px">
				  
				   <i class="fa fas fa-play-circle" style="position: absolute;left:50px" ></i>
			      
		          <span>追番</span>
                  </a>
                </li>
              
                <li>

                  <a href="/musics " style="margin-left:75px">
				  
				   <i class="fa fas fa-music" style="position: absolute;left:50px" ></i>
			      
		          <span>音乐</span>
                  </a>
                </li>
              
            </ul>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    <main id="main_wrap">
        





<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/suoluetu1.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">微服务（SpringCloud、SpringCloudAlibaba）</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/fenghen0918/fenghen0918.github.io/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
        background-color: rgb(255, 255, 255,0.7);
        border-radius: 10px;
        box-shadow: 0 10px 35px 2px rgba(0, 0, 0, .15), 0 5px 15px rgba(0, 0, 0, .07), 0 2px 5px -5px rgba(0, 0, 0, .1) !important;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/SpringCloud/">
                                <span class="chip bg-color">SpringCloud</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/SpringCloud/" class="post-category">
                                SpringCloud
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-09-24
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    13.9k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    53 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><p>微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间相互协调，相互配合，为用户体现最终价值。每个服务运行在其独立的进程当中，服务与服务之间采用轻量级的通信机制互相协作（通常是基于http/restful API）。</p>
<h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1><p>分布式微服务架构的一站式解决方案，是多种微服务架构的技术集合体，俗称微服务全家桶。</p>
<h2 id="SpringCloud技术栈"><a href="#SpringCloud技术栈" class="headerlink" title="SpringCloud技术栈"></a>SpringCloud技术栈</h2><p>服务注册与发现：EUREKA、Zookeeper、consul、Nacos</p>
<p>服务负载与调用：RIBBON、OPEN FEIGN</p>
<p>服务熔断降级：HYSTRIX、Sentinel</p>
<p>服务网关：Zuul，GateWay</p>
<p>服务分布式配置：Spring Cloud Config、Nacos</p>
<p>服务消息总线：Spring Cloud Bus、Nacos</p>
<p>服务开发：Spring Boot</p>
<h2 id="Boot和Cloud技术选型"><a href="#Boot和Cloud技术选型" class="headerlink" title="Boot和Cloud技术选型"></a>Boot和Cloud技术选型</h2><p>SpringBoot2.X版和SpringCloud H版</p>
<p>SpringCloud Alibaba</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200917232433.png" alt="1"></p>
<h2 id="微服务架构编码构建"><a href="#微服务架构编码构建" class="headerlink" title="微服务架构编码构建"></a>微服务架构编码构建</h2><h3 id="微服务cloud整体聚合父工程Project"><a href="#微服务cloud整体聚合父工程Project" class="headerlink" title="微服务cloud整体聚合父工程Project"></a>微服务cloud整体聚合父工程Project</h3><ul>
<li><p>父工程步骤</p>
<ul>
<li>1.New Project</li>
<li>2.聚合总工程名字</li>
<li>3.Maven选版本</li>
<li>4.工程名字</li>
<li>5.字符编码</li>
<li>6.注解生效激活</li>
<li>7.java编译版本选8</li>
<li>8.File Type过滤</li>
</ul>
</li>
<li><p>Maven工程落地细节复习</p>
<ul>
<li>Maven中的dependencyManagement和dependencies<ul>
<li>dependencyManagement：只在父工程中出现，用于版本固定，不会引入Jar包</li>
</ul>
</li>
<li>maven中跳过单元测试</li>
</ul>
</li>
<li><p>父工程创建完成执行mvn:install将父工程发布到仓库方便子工程继承</p>
</li>
</ul>
<h3 id="创建子模块-pay模块"><a href="#创建子模块-pay模块" class="headerlink" title="创建子模块,pay模块"></a>创建子模块,pay模块</h3><ol>
<li>创建module</li>
<li>改pom</li>
<li>写yml</li>
<li>主启动</li>
<li>业务类</li>
</ol>
<h4 id="业务类"><a href="#业务类" class="headerlink" title="业务类"></a>业务类</h4><ol>
<li><p>sql</p>
</li>
<li><p>实体类</p>
<ol>
<li>CommonResult类</li>
<li>实体类</li>
</ol>
</li>
<li><p>dao</p>
<ol>
<li><p>接口</p>
</li>
<li><p>mabatis映射文件</p>
<p>在resource下,创建mapper/PayMapper.xml</p>
</li>
</ol>
</li>
<li><p>service</p>
<ol>
<li>service</li>
<li>impl</li>
</ol>
</li>
<li><p>controller</p>
</li>
</ol>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><ul>
<li><p><code>postman</code>模拟post请求</p>
</li>
<li><p>切换Run DashBoard运行窗口（分布式的运行窗口）</p>
<ul>
<li>在项目路径的.idea/workspace.xml</li>
</ul>
<pre><code>填入以下内容：
&lt;option name="configurationTypes"&gt;
      &lt;set&gt;
        &lt;option value="SpringBootApplicationConfigurationType" /&gt;
      &lt;/set&gt;
    &lt;/option&gt;
</code></pre>
</li>
</ul>
<h3 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h3><h3 id="order模块"><a href="#order模块" class="headerlink" title="order模块"></a>order模块</h3><ol>
<li>创建module</li>
<li>改pom</li>
<li>写yml</li>
<li>主启动</li>
<li>业务类</li>
</ol>
<h4 id="业务类-1"><a href="#业务类-1" class="headerlink" title="业务类"></a>业务类</h4><ol>
<li><p>复制pay模块的实体类,entity类</p>
</li>
<li><p>写controller类</p>
<p>因为这里是消费者类,主要是消费,那么就没有service和dao,需要调用pay模块的方法</p>
<p>并且这里还没有微服务的远程调用,那么如果要调用另外一个模块,则需要使用基本的api调用</p>
<p>使用RestTemplate调用pay模块</p>
<p>RestTemplate(看脑图)：用于服务间的调用</p>
<blockquote>
<p>注意：使用RestTemplate调用服务传输的是json数据，springboot并不能直接封装进对象中。需要在转发过去的方法中（即8001）使用@RequestBody让json数据封装进对象中，才能加入到数据库里。之前成功是因为url提交的是表单数据，非json数据</p>
</blockquote>
</li>
</ol>
<h3 id="工程重构（解决entity重复）"><a href="#工程重构（解决entity重复）" class="headerlink" title="工程重构（解决entity重复）"></a>工程重构（解决entity重复）</h3><h2 id="Eureka服务注册与发现"><a href="#Eureka服务注册与发现" class="headerlink" title="Eureka服务注册与发现"></a>Eureka服务注册与发现</h2><p>当服务很多时,每个服务之间的依赖关系会比较复杂，管理起来更为复杂，需要服务管理服务间的依赖关系，实现负载均衡、服务调用等，实现服务注册与发现。</p>
<p>Eureka采用CS设计架构，server是服务器，也是注册中心，当eureka客户端连接到服务器，这样维护人员就可以在服务器监控各个服务的正常运行。</p>
<p>当服务器启动时，就会把自己的服务器信息以别名的方式注册在注册中心，消费者，服务提供者都以别名的方式获取该服务的通讯地址，实现本地的RPC调用思想：使用注册中心管理每个服务之间的依赖关系。</p>
<p><strong>Eureka的两个组件</strong>：</p>
<ol>
<li><p>客户端：在各个服务上，比如登录微服务，启动后会给服务器发送心跳，证明自己还存活</p>
</li>
<li><p>服务器：服务器端，用于接收心跳（类似工商管理局）</p>
</li>
</ol>
<h3 id="单机版Eureka"><a href="#单机版Eureka" class="headerlink" title="单机版Eureka"></a>单机版Eureka</h3><h4 id="服务器创建"><a href="#服务器创建" class="headerlink" title="服务器创建"></a>服务器创建</h4><ol>
<li><p>创建项目cloud_eureka_server_7001</p>
</li>
<li><p>引入pom依赖</p>
<p>Eureka新版本</p>
</li>
<li><p>写yml</p>
</li>
<li><p>主启动</p>
<p>加上@EnableEurekaServer，表示服务是server</p>
</li>
<li><p>测试</p>
</li>
</ol>
<h4 id="注册客户端8001进服务器成为服务提供者provider"><a href="#注册客户端8001进服务器成为服务提供者provider" class="headerlink" title="注册客户端8001进服务器成为服务提供者provider"></a>注册客户端8001进服务器成为服务提供者provider</h4><h4 id="其他服务注册进服务器"><a href="#其他服务注册进服务器" class="headerlink" title="其他服务注册进服务器"></a>其他服务注册进服务器</h4><p>8001、80都注册进去</p>
<ol>
<li><p>改pom依赖</p>
</li>
<li><p>写Yml</p>
</li>
<li><p>主启动</p>
<p>加上@EnableEurekaClient</p>
</li>
<li><p>服务模块重启</p>
</li>
</ol>
<h3 id="集群Eureka"><a href="#集群Eureka" class="headerlink" title="集群Eureka"></a>集群Eureka</h3><p><strong>集群原理</strong>：</p>
<p>服务注册：将服务信息注册进注册中心</p>
<p>服务发现：从注册中心获取服务信息</p>
<p>实质：key服务名，value调用地址</p>
<ul>
<li>先启动注册中心，再启动服务，服务启动时会将信息以别名的方式注册进注册中心，消费者可以通过使用服务的别名在注册中心获取RPC远程调用地址，底层使用的是HttpClient实现的远程调用。在消费者获取服务地址之后，就会将其缓存在jvm内存中，没30秒更新一次</li>
<li>RPC远程调用最核心的就是：高可用，一个瘫痪，全部升天。所以集群有多个组成，并且<strong>互相注册，相互守望</strong>，如：有3台服务器，则1注册12，2-13，3-12</li>
</ul>
<h4 id="构建新erueka服务器"><a href="#构建新erueka服务器" class="headerlink" title="构建新erueka服务器"></a>构建新erueka服务器</h4><ol>
<li>cloud_eureka_server_7002</li>
<li>pom文件：粘贴7001的</li>
<li>配置文件<ol>
<li>修改本地的host文件（看脑图，非yaml）</li>
<li>修改yml，进行相互注册（注意defautlZone），7001，7002都要修改</li>
</ol>
</li>
<li>主启动类</li>
<li>启动测试</li>
</ol>
<h4 id="将服务模块注册进集群中"><a href="#将服务模块注册进集群中" class="headerlink" title="将服务模块注册进集群中"></a>将服务模块注册进集群中</h4><ol>
<li>修改yml文件（defaultZone加一条即可，两个模块都要加）</li>
<li>启动模块，先启动服务器7001，7002，再启动8001，之后是80</li>
<li>测试</li>
</ol>
<h4 id="构建新的服务提供者8001集群"><a href="#构建新的服务提供者8001集群" class="headerlink" title="构建新的服务提供者8001集群"></a>构建新的服务提供者8001集群</h4><ol>
<li>创建新模块,8002（cloud_pay_8002）</li>
<li>pom文件,复制8001的</li>
<li>yml文件修改端口（服务名称不用改，用一样的，为的是为消费者暴露一样的别名）</li>
<li>主启动类,复制8001的</li>
<li>mapper,service,controller都复制一份</li>
<li>实现负载均衡<ol>
<li>controller的url不能写死，改成微服务名称，这样每次访问就会从eureka中拿地址，轮询</li>
<li>在注册bean的restTemplate方法上加上@LoadBalanced开启负载均衡</li>
</ol>
</li>
</ol>
<h3 id="修改服务主机名和ip在eureka的web上显示"><a href="#修改服务主机名和ip在eureka的web上显示" class="headerlink" title="修改服务主机名和ip在eureka的web上显示"></a>修改服务主机名和ip在eureka的web上显示</h3><p>作用：修改在eureka显示的默认主机名，鼠标移到主机名会显示ip</p>
<ol>
<li>修改yml文件</li>
</ol>
<h3 id="eureka服务发现"><a href="#eureka服务发现" class="headerlink" title="eureka服务发现:"></a>eureka服务发现:</h3><p>对于注册进eureka里面的微服务，可以通过服务发现来获取该服务的信息</p>
<ol>
<li>在controller自动注入DiscoveryClient</li>
<li>用方法获取各种信息（所有服务集群、服务集群中的服务名、IP、端口、URI）</li>
<li>主启动类加入注解：@EnableDiscoveryClient</li>
<li>重启测试</li>
</ol>
<h3 id="Eureka自我保护机制"><a href="#Eureka自我保护机制" class="headerlink" title="Eureka自我保护机制"></a>Eureka自我保护机制</h3><ul>
<li><p>某个微服务不可用时（客户端没有定时向服务器端发送心跳包），Eureka不会立刻将其清理，依旧会对该服务信息进行保存。</p>
</li>
<li><p>Eureka属于CAP中的AP分支（高可用）</p>
<ul>
<li>CAP：<ul>
<li>C：高一致性</li>
<li>A：高可用</li>
<li>P：高容错（因为分布式微服务架构都需要高容错，P必备）</li>
</ul>
</li>
<li>AP：Eureka</li>
<li>CP：Zookeeper/Consul</li>
</ul>
</li>
</ul>
<p><strong>如何禁止自我保护：</strong></p>
<p>此时启动erueka和pay.此时如果直接关闭了pay,那么erueka会直接删除其注册信息</p>
<p>修改yml文件</p>
<ol>
<li>注册中心server<ol>
<li>关闭自我保护</li>
<li>设置接收心跳时间（测试用）</li>
</ol>
</li>
<li>客户端client<ol>
<li>设置发送心跳时间</li>
<li>设置服务端在收到最后一次心跳等待上限</li>
</ol>
</li>
<li>测试</li>
</ol>
<h2 id="Zookeeper服务注册与发现"><a href="#Zookeeper服务注册与发现" class="headerlink" title="Zookeeper服务注册与发现"></a>Zookeeper服务注册与发现</h2><h3 id="注册中心服务器Zookeeper"><a href="#注册中心服务器Zookeeper" class="headerlink" title="注册中心服务器Zookeeper"></a>注册中心服务器Zookeeper</h3><ol>
<li>它是一个分布式协调工具，可以实现注册中心功能</li>
<li>关闭linux服务器防火墙，启动zookeeper服务器</li>
</ol>
<h3 id="服务提供者，客户端"><a href="#服务提供者，客户端" class="headerlink" title="服务提供者，客户端"></a>服务提供者，客户端</h3><ol>
<li><p>创建新的pay服务模块</p>
<p>cloud_pay_8003，单独用于注册到zk中  </p>
<ol>
<li><p>pom依赖</p>
</li>
<li><p>yml配置文件（端口号，服务别名，zookeeper服务器ip+端口号）</p>
</li>
<li><p>主启动</p>
</li>
<li><p>controller</p>
</li>
<li><p>修改zk版本和jar冲突</p>
<p>解决:</p>
<pre><code>    修改pom文件,改为与我们zk版本匹配的jar包
</code></pre>
</li>
<li><p>启动，此时8003就注册到zk中了</p>
<ul>
<li><p>此时服务就会作为<strong>临时节点</strong>存入zk中，信息作为流水号存在临时节点中。</p>
</li>
<li><p>当我们的服务一定时间内没有发送心跳</p>
<pre><code>  那么zk就会将这个服务的node删除了
</code></pre>
</li>
<li><p>这里是测试,就不写service与dao什么的了</p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h3><ol>
<li>cloud_order_zk_80</li>
<li>pom</li>
<li>yml配置文件</li>
<li>主启动</li>
<li>restTemplate</li>
<li>controller</li>
<li>启动注册</li>
</ol>
<h3 id="集群zk的注册"><a href="#集群zk的注册" class="headerlink" title="集群zk的注册"></a>集群zk的注册</h3><ol>
<li>zookeeper教学中的集群搭建</li>
<li>服务提供者和消费者在配置文件中connect-string指定多个zk地址即可 “，”隔开</li>
</ol>
<h2 id="Consul服务注册与发现"><a href="#Consul服务注册与发现" class="headerlink" title="Consul服务注册与发现"></a>Consul服务注册与发现</h2><p>它是一个服务发现、配置管理系统</p>
<p>作用：服务发现、健康检测、KV存储、可视化web界面</p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><ol>
<li>需要下载一个安装包，是个exe文件</li>
<li>启动是一个命令行界面,需要输入consul agen-dev启动</li>
<li>localhost:8500查看页面</li>
</ol>
<h3 id="创建服务提供者模块pay-8006"><a href="#创建服务提供者模块pay-8006" class="headerlink" title="创建服务提供者模块pay,8006"></a>创建服务提供者模块pay,8006</h3><ol>
<li>cloud_consule_pay_8006</li>
<li>pom依赖</li>
<li>yml配置文件（需要写服务的名字）</li>
<li>主启动类</li>
<li>controller</li>
<li>启动服务，观察是否注册进去</li>
</ol>
<h3 id="创建消费者模块order"><a href="#创建消费者模块order" class="headerlink" title="创建消费者模块order"></a>创建消费者模块order</h3><ol>
<li><p>cloud-consul-order-80</p>
</li>
<li><p>pom依赖</p>
</li>
<li><p>yml配置文件（需要写服务的名字）</p>
</li>
<li><p>主启动类</p>
</li>
<li><p>RestTemplate注册</p>
<p>配置类注册</p>
</li>
<li><p>controller</p>
</li>
<li><p>启动服务,测试是否注册进去，测试方法是否成功执行</p>
</li>
</ol>
<h2 id="三个注册中心的异同"><a href="#三个注册中心的异同" class="headerlink" title="三个注册中心的异同"></a>三个注册中心的异同</h2><p>Eureka：AP，以高可用为原则（如Eureka的自我保护机制：宕机依然保留数据）</p>
<p>Consul/Zookeeper：CP，以高一致性为原则，（如Zookeeper的临时节点：宕机直接踢出）</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200919144043.png" alt="zhuce1"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200919144116.png" alt="zhuce2"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200919144127.png" alt="zhuce3"></p>
<h2 id="Ribbon负载均衡服务调用"><a href="#Ribbon负载均衡服务调用" class="headerlink" title="Ribbon负载均衡服务调用"></a>Ribbon负载均衡服务调用</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>它是一个客户端，提供客户端（服务提供者）的软件负载均衡算法和服务调用。</p>
<p>作用：LB负载均衡（集中式负载均衡，进程内负载均衡）</p>
<ul>
<li>负载均衡：将用户的请求平摊在多个服务上，实现高可用</li>
</ul>
<p><strong>Ribbon本地负载均衡和Nginx服务端负载均衡的区别</strong></p>
<p>Nginx是服务器端的负载均衡，客户端将请求交给nginx，nginx实现转发请求</p>
<p>ribbon是客户端的负载均衡，会在注册中心拿到注册中心的信息服务列表加到缓存中，从而在本地实现RPC远程服务调用</p>
<p><strong>工作机制</strong></p>
<p>Ribbon就是负载均衡+RestTemplate，它就是一个软负载均衡的<strong>客户端</strong>组件，需要和其他<strong>客户端</strong>结合起来，如和eureka结合</p>
<ol>
<li>在选择EurekaServer，它优先选择在同一区域的负载较少的server</li>
<li>根据用户的指定策略（轮询、随机、加权），在server里取到信息，进行调用</li>
</ol>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol>
<li><p>引入jar包，但默认我们使用eureka的新版本时,它默认集成了ribbon，所以不需要引入</p>
<p>spring-cloud-starter-netflix-eureka-client集成了reibbon</p>
<p>也可以手动引入，放到order（消费者）模块中,因为只有order访问pay时需要负载均衡</p>
</li>
<li><p>RestTemplate类:</p>
<ol>
<li>getForObject（url,返回值.class）：返回的是响应体数据转化成的对象，即json</li>
<li>getForEntity（url,返回值.class）：返回的是重要信息（响应头、体、状态码），可以通过返回对象的get方法获得这些信息</li>
</ol>
</li>
</ol>
<h3 id="Ribbon常用负载均衡算法"><a href="#Ribbon常用负载均衡算法" class="headerlink" title="Ribbon常用负载均衡算法:"></a>Ribbon常用负载均衡算法:</h3><p><strong>核心组件</strong>：IRule接口,Riboon使用该接口,根据特定算法从所有服务中,选择一个服务</p>
<p><strong>Rule接口有7个实现类,每个实现类代表一个负载均衡算法</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200919154159.png" alt="rule"></p>
<p><strong>替换</strong>：</p>
<ol>
<li><p>选择需要修改的消费者模块</p>
</li>
<li><p>需要自定义配置类，<strong>不能放在主启动类所在的包及子包下</strong></p>
</li>
<li><p>额外创建一个包：和启动器的父包是兄弟包</p>
</li>
<li><p>创建配置类,指定负载均衡算法</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200919154543.png" alt="rule2"></p>
</li>
<li><p>在主启动类上加一个注解@RibbonClient</p>
<ul>
<li>name:要访问服务的名字</li>
<li>configuration：自定义配置类的class文件</li>
</ul>
</li>
</ol>
<h3 id="自定义负载均衡算法"><a href="#自定义负载均衡算法" class="headerlink" title="自定义负载均衡算法:"></a>自定义负载均衡算法:</h3><h4 id="轮询算法原理"><a href="#轮询算法原理" class="headerlink" title="轮询算法原理"></a>轮询算法原理</h4><p><strong>rest接口第几次请求 % 服务器集群总数量（集群中的机器数） = 实际调用服务器的下标</strong>，重启服务器后，计数从1开始</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200919160044.png"></p>
<h4 id="自定义负载均衡算法（跳）"><a href="#自定义负载均衡算法（跳）" class="headerlink" title="自定义负载均衡算法（跳）"></a>自定义负载均衡算法（跳）</h4><h2 id="OpenFeign-服务接口调用"><a href="#OpenFeign-服务接口调用" class="headerlink" title="OpenFeign 服务接口调用"></a>OpenFeign 服务接口调用</h2><p>它是webService<strong>客户端</strong>（消费者端），使用方法是：<strong>定义一个服务接口，然后在上面添加注解，写上需要调用的方法，使用时调用这个接口中的方法，即可完成微服务之间的调用</strong>，实现接口间的远程调用，不再用Ribbon和restTemplate一样远程调用</p>
<p><strong>就是A要调用B,Feign就是在A中创建一个一模一样的B对外提供服务的的接口,我们调用这个接口,就可以服务到B</strong></p>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><ol>
<li><p>新建一个order项目,用于feign测试</p>
<p>cloud_order_feign-80</p>
</li>
<li><p>pom文件（引入openFeign的jar包）</p>
</li>
<li><p>yml配置文件（因为是客户端，不注册进注册中心也可以）</p>
</li>
<li><p>主启动类（@EnableFeignClients，启动feign）</p>
</li>
<li><p>需要调用的其他的服务的接口（这里本应该是8001 Service接口中的方法，但controller也是调用的service方法，所以是一样的）</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200919165041.png" alt="feign"></p>
</li>
<li><p>controller(自动注入接口，调用接口的方法，实现远程调用)</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200919165539.png" alt="feign2"></p>
</li>
<li><p>测试</p>
<p>启动7001，7002</p>
<p>启动8001，8002</p>
<p>启动当前80模块</p>
<p><strong>Feign默认使用ribbon实现负载均衡</strong></p>
<p>测试方法是否成功调用</p>
</li>
</ol>
<h3 id="OpenFeign超时机制"><a href="#OpenFeign超时机制" class="headerlink" title="OpenFeign超时机制:"></a>OpenFeign超时机制:</h3><p>有时我们业务逻辑处理需要久一点，不能很快的让消费者远程调用到，我们需要改一下超时时间</p>
<p><strong>OpenFeign默认等待时间是1秒,超过1秒,直接报错</strong></p>
<ol>
<li><p>设置超时时间，修改yml配置文件</p>
<p>因为OpenFeign的底层是ribbon进行负载均衡,所以它的超时时间是由ribbon控制</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200919171342.png" alt="feign3"></p>
</li>
</ol>
<h3 id="OpenFeign日志"><a href="#OpenFeign日志" class="headerlink" title="OpenFeign日志:"></a>OpenFeign日志:</h3><p>它提供了日志打印功能，可以通过配置日志级别，从而了解http请求的细节，就是对<strong>feign接口的调用情况的监控和输出</strong></p>
<p><strong>OpenFeign的日志级别有:</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200919171937.png" alt="log"></p>
<h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><ol>
<li><p>实现在配置类中添加OpenFeign的日志类（指定http日志级别）</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200919172102.png" alt="log2"></p>
</li>
<li><p>修改yml配置文件（指定命令行日志级别、哪个接口实现日志监控）</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200919172137.png" alt="log3"></p>
</li>
<li><p>启动服务测试</p>
</li>
</ol>
<h2 id="Hystrix服务降级"><a href="#Hystrix服务降级" class="headerlink" title="Hystrix服务降级"></a>Hystrix服务降级</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><ol>
<li>服务雪崩：当多个微服务之间互相调用时，a-b-c-d……，这就是所谓的“扇出”，当某个微服务不管用，对a就会占用越来越多的资源，进而引起系统崩溃，雪崩</li>
<li>它是一个用于处理分布式的延迟和容错，当出现问题时不会导致级联故障，而是返回一个符合预期的备选响应，提高分布式弹性</li>
<li>服务降级：当服务繁忙时，不能一直等待，会返回客户端一个备选方案<ol>
<li>程序运行异常</li>
<li>超时</li>
<li>服务熔断触发服务降级</li>
<li>线程池打满</li>
<li>宕机</li>
</ol>
</li>
<li>服务熔断：当服务出现问题，出现故障，先关闭对此服务的访问，防止级联故障，再调用服务降级，最后恢复</li>
<li>服务限流：当并发量增大，限制访问的请求数量</li>
</ol>
<h3 id="使用服务降级"><a href="#使用服务降级" class="headerlink" title="使用服务降级"></a>使用服务降级</h3><h4 id="创建服务提供者模块（测试服务降级用）"><a href="#创建服务提供者模块（测试服务降级用）" class="headerlink" title="创建服务提供者模块（测试服务降级用）"></a>创建服务提供者模块（测试服务降级用）</h4><ol>
<li>cloud-hystrix-pay-8007</li>
<li>pom</li>
<li>yml</li>
<li>主启动（@EnableEurekaClient）</li>
<li>service（正常访问方法、睡3秒方法）</li>
<li>controller</li>
<li>压力测试JMeter（还没有加入hystrix服务降级）</li>
</ol>
<h4 id="创建消费者模块（测试服务降级用）"><a href="#创建消费者模块（测试服务降级用）" class="headerlink" title="创建消费者模块（测试服务降级用）"></a>创建消费者模块（测试服务降级用）</h4><ol>
<li><p>cloud-hystrix-order-80</p>
</li>
<li><p>pom</p>
</li>
<li><p>yml</p>
</li>
<li><p>主启动（@EnableFeignClients）</p>
</li>
<li><p>远程调用接口（@FeignClient(value=”服务名”)）</p>
</li>
<li><p>controller（调用接口）</p>
</li>
<li><p>压力测试</p>
<p>出现问题：2W并发之后，消费者的访问速度变慢</p>
</li>
</ol>
<p><strong>解决方案</strong></p>
<ol>
<li>超时：不再等待</li>
<li>出错（宕机或运行出错）：兜底</li>
</ol>
<h4 id="配置服务降级"><a href="#配置服务降级" class="headerlink" title="配置服务降级"></a>配置服务降级</h4><p>==<strong>一般服务降级,都是放在客户端</strong>==</p>
<p>==<strong>热部署对@HystrixCommand注解不太敏感，建议修改完重启服务</strong>==</p>
<p><strong>修改服务提供者payment模块</strong></p>
<ol start="0">
<li><p>创建一个用于兜底的方法</p>
</li>
<li><p>为service的指定方法(会延迟的方法)添加@HystrixCommand注解</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@HystrixCommand</span><span class="token punctuation">(</span>fallbackMethod <span class="token operator">=</span> <span class="token string">"paymentTimeOutFallbackMethod"</span><span class="token punctuation">,</span>commandProperties <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@HystrixProperty</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"execution.isolation.thread.timeoutInMilliseconds"</span><span class="token punctuation">,</span>value <span class="token operator">=</span> <span class="token string">"3000"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//3秒钟以内就是正常的业务逻辑</span>
<span class="token comment" spellcheck="true">//设定超时时间</span>
</code></pre>
</li>
<li><p>主启动类上,添加激活hystrix的注解@EnableCircuitBreaker</p>
</li>
<li><p>测试：</p>
<ol>
<li>设置方法时间&gt;设定时间</li>
<li>设置异常</li>
</ol>
</li>
</ol>
<p><strong>修改消费者order模块</strong></p>
<ol>
<li><p>修改yml配置文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200920150237.png" alt="hystrix1"></p>
</li>
<li><p>主启动类添加注解,启用hystrix，@EnableHystrix</p>
</li>
<li><p>修改controller,添加要测试的降级方法和相关注解</p>
</li>
<li><p>测试</p>
<ol>
<li>设置方法时间&gt;设定时间</li>
<li>设置异常</li>
<li>这里pay模块和order模块都开启了服务降级，但服务提供者3秒，消费者设置为1.5秒，一定会被降级</li>
</ol>
</li>
</ol>
<p><strong>出现的问题</strong></p>
<ol>
<li>每个业务方法都写了一个降级方法,重复代码多</li>
<li>降级方法与业务方法写在了一块,耦合度高</li>
</ol>
<p>解决1：</p>
<p><strong>配置一个全局的降级方法,所有方法都可以走这个降级方法,至于某些特殊创建,如上述的一样再单独创建方法</strong></p>
<ol>
<li><p>消费者模块创建一个全局方法</p>
</li>
<li><p>在类上使用注解指定其为全局降级方法(默认降级方法)</p>
<p>@DefaultProperties(defaultFallback=”定义的全局方法”)</p>
</li>
<li><p>在方法上加注解@HystrixCommand，不用指定降级方法，使用默认全局</p>
</li>
<li><p>测试</p>
</li>
</ol>
<p>解决2：</p>
<p>修改消费者模块</p>
<ol>
<li><p>创建一个类实现远程接口,在实现类中统一处理异常</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200920154351.png" alt="h1"></p>
</li>
<li><p>修改配置文件:添加:</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200920150237.png" alt="hystrix1"></p>
</li>
<li><p>接口中注解增加fallback属性，让PayService的实现类生效:</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200920154225.png" alt="h2"></p>
</li>
</ol>
<p>它的运行逻辑是:<br>        当请求过来,首先还是通过Feign远程调用pay模块对应的方法，但是如果pay模块报错(宕机，无法调用),调用失败,那么就会调用PayMentFalbackService类的当前同名的方法,作为降级方法</p>
<ol start="4">
<li><p>测试：</p>
<p>启动正常访问后，关闭服务提供者，消费者再次访问，转向fallback方法</p>
</li>
</ol>
<p><strong>这样虽然解决了代码耦合度问题,但是又出现了过多重复代码的问题,每个方法都有一个降级方法</strong></p>
<h3 id="使用服务熔断"><a href="#使用服务熔断" class="headerlink" title="使用服务熔断"></a>使用服务熔断</h3><p>当达到最大访问次数时,出现问题概率大，拒绝访问，拉闸，调用降级的方法</p>
<p>机制：当某个服务不可用或响应时间太长，熔断该微服务，快速返回错误响应信息，当检测到恢复正常，再恢复调用链路</p>
<p>如：当失败调用到一定阈值，5秒内20次调用失败，就会启动熔断机制，熔断机制是注解@HystrixCommand</p>
<p><strong>修改服务提供者模块</strong></p>
<ol>
<li><p>修改Payservice接口,添加服务熔断相关的方法:</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200920160927.png" alt="r1"></p>
<p>10秒之内(窗口,会移动),如果并发==超过==10个,或者10个并发中,失败了6个,就开启熔断器</p>
<p>IdUtil是Hutool包下的类,这个Hutool就是整合了所有的常用方法,比如UUID,反射,IO流等工具方法什么的都整合了</p>
<p>断路器的打开和关闭,是按照一下5步决定的</p>
<ol>
<li>并发此时是否达到我们指定的阈值（默认10秒20次请求），到了阈值才有资格熔断</li>
<li>错误百分比,比如我们配置了60%（默认10秒50%请求）,那么如果并发请求中,10次有6次是失败的,就开启断路器</li>
<li>上面的两个条件符合,断路器改变状态为open(<strong>开启</strong>)，拉闸</li>
<li>这个服务的断路器开启,所有请求无法访问</li>
<li>熔断之后，开启休眠时间窗（默认5秒），此时只会执行降级逻辑，休眠时间窗结束之后，尝试让一些请求通过(<strong>半开状态half Open</strong>),如果请求还是失败,证明断路器还是开启状态,服务没有恢复，如果请求成功了,证明服务已经恢复,断路器状态变为close<strong>关闭</strong>状态，恢复</li>
</ol>
</li>
</ol>
<p><strong>其他参数</strong>：见脑图</p>
<h3 id="服务限流（sentinel会详说）"><a href="#服务限流（sentinel会详说）" class="headerlink" title="服务限流（sentinel会详说）"></a>服务限流（sentinel会详说）</h3><h3 id="Hystrix服务监控"><a href="#Hystrix服务监控" class="headerlink" title="Hystrix服务监控:"></a>Hystrix服务监控:</h3><p>一个图形化界面的实时监控平台</p>
<p><strong>使用</strong>：</p>
<ol>
<li><p>创建监控平台模块（需要创建模块，比较麻烦，后面sentinel不需要）</p>
<p>cloud_hystrixdashboard_9001</p>
</li>
<li><p>pom文件（导入依赖dashboard）</p>
</li>
<li><p>配置文件</p>
<p>server: port:9001</p>
</li>
<li><p>主启动类@EnableHystrixDashboard</p>
</li>
<li><p>修改需要监控的模块（8001，8002）</p>
<ol>
<li><p>增加pom依赖（以前都增加有）</p>
<p>actuator，这个是springboot的监控组件</p>
</li>
</ol>
</li>
<li><p>启动</p>
<p>访问: <strong>localhost:9001/hystrix</strong></p>
<p>注意,此时仅仅是可以访问HystrixDashboard,并不代表已经监控了8001,8002</p>
</li>
<li><p>如果要监控,还需要配置:(8001为例)</p>
<ol>
<li><p>8001主启动类添加</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200920173822.png"></p>
<p><strong>其他8002,8003都是一样的</strong></p>
</li>
</ol>
</li>
<li><p>启动服务7001，8001，9001</p>
</li>
<li><p>然后在web界面,指定9001要监控8001:</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200920173933.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200920174000.png"></p>
</li>
</ol>
<h2 id="GateWay服务网关"><a href="#GateWay服务网关" class="headerlink" title="GateWay服务网关"></a>GateWay服务网关</h2><p>zuul停更了</p>
<h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>GateWay是Spring生态系统上构建的API网关服务，替代了zuul，基于WebFlux框架，而WebFlux框架底层使用了高性能的Reactor模式通信框架Netty。</p>
<p><strong>gateway之所以性能好,因为底层使用WebFlux,而webFlux底层使用netty通信(NIO)</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200921082820.png"></p>
<p><strong>特性</strong>：动态路由（能匹配任何请求），可对路由指定断言、过滤器，集成断路器、SpringCloud服务发现，请求限流</p>
<p><strong>GateWay与zuul的区别:</strong></p>
<ol>
<li>Zuul1是基于Sevlet2.5使用<strong>阻塞架构</strong>，每次IO操作都从工作线程中选一个执行，请求线程会阻塞到工作线程完成，性能较差</li>
<li>gateWay使用<strong>非阻塞API</strong>，建立在spring5， project Reactor和spring boot2之上</li>
</ol>
<p><strong>路由</strong>：构建网关的基本模块，它由ID，目标URI，一系列断言和过滤器组成，通过断言为true则匹配该路由</p>
<p>即根据某些规则，将请求转发给指定服务</p>
<p><strong>断言</strong>：开发人员可以通过http请求中的内容，与断言相匹配则可以进行路由</p>
<p><strong>过滤</strong>：在路由的前后对请求进行修改</p>
<p><strong>工作流程</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200921084504.png"></p>
<p><strong>就是路由转发+执行过滤器链</strong></p>
<h3 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h3><ol>
<li><p>新建网关模块GateWay</p>
<p>cloud_gateway_9527</p>
</li>
<li><p>pom（引入网关依赖gateWay）</p>
</li>
<li><p>yml配置文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200921143943.png"></p>
</li>
<li><p>主启动</p>
</li>
<li><p>根据服务提供者模块，设置路由网关</p>
<p>我们不想暴露8001端口，所以在8001上套了一层9527</p>
<ol>
<li><p>修改网关的yml配置文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200921143857.png"></p>
</li>
</ol>
<p>意思就是：</p>
<p>当访问localhost:9527/payment/get/1时,     </p>
<p>路由到localhost:8001/payment/get/1</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200921144047.png"></p>
</li>
</ol>
<p><strong>以上是配置文件配置，也可以用硬编码配置，比较麻烦所以还是选择配置文件的方式</strong></p>
<h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>默认情况gateWay会根据服务中心的服务列表，以微服务名为路径创建动态路由进行转发</p>
<p><strong>使用</strong>：</p>
<ol>
<li><p>需要1个服务器、两个微服务提供者</p>
</li>
<li><p>修改网关yml文件（开启路由功能，修改路由地址）</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200921145814.png"></p>
</li>
<li><p>启动微服务，进行测试</p>
</li>
</ol>
<h3 id="Pridicate断言"><a href="#Pridicate断言" class="headerlink" title="Pridicate断言"></a>Pridicate断言</h3><p><strong>相当于网关的规则，满足了这些规则，找到对应的路由</strong></p>
<p>其中<code>predicates:path=/payment/get/**</code>就是一个断言</p>
<p>这个断言表示,如果外部访问路径是指定路径,就路由到指定微服务上</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200921151640.png"></p>
<ol>
<li>After:只有在指定时间后,才可以路由到指定微服务</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200921152144.png"></p>
<ol start="2">
<li><p>before:在指定时间前访问</p>
</li>
<li><p>between:需要指定两个时间，在这之间的时间可以访问</p>
</li>
<li><p>cookie:只有包含某些指定cookie（key,value）的请求才可以路由</p>
<ul>
<li>需要由两个参数，key名，value值</li>
</ul>
</li>
<li><p>Header:只有包含指定请求头的请求,才可以路由</p>
<ul>
<li>需要两个参数，header名，正则表达式，如：x-Request-id，\d+ 正整数</li>
</ul>
</li>
<li><p>host:只有指定主机的才可以访问，如：Host=**.shangguigu.com</p>
<ol>
<li>测试：curl <a target="_blank" rel="noopener" href="http://localhost:9527/paymentinfo">http://localhost:9527/paymentinfo</a> -H “host:<a target="_blank" rel="noopener" href="http://www.shangguigu.com&quot;/">www.shangguigu.com"</a></li>
<li><strong>curl是命令行发送请求的方式，postman可视化图形界面的底层就是使用这个</strong></li>
</ol>
</li>
<li><p>method:只有指定请求才可以路由,比如get请求…</p>
<ol>
<li>Method=GET</li>
</ol>
</li>
<li><p>path:只有访问指定路径,才进行路由</p>
</li>
<li><p>Query:必须带有请求参数才可以访问，</p>
<ol>
<li>需要两个参数，参数名，正则表达式，如：Query=username,\d+</li>
<li>localhost:9527?username=123</li>
</ol>
</li>
</ol>
<h3 id="Filter过滤器"><a href="#Filter过滤器" class="headerlink" title="Filter过滤器"></a>Filter过滤器</h3><p><strong>种类</strong>：</p>
<p>GatewayFilter：单一的过滤器，与断言类似（怎么加看官网）</p>
<p>GlobalFilter：全局过滤器</p>
<p><strong>自定义过滤器</strong>（全局，常用）</p>
<ol>
<li><p>自己创建一个过滤器类，实现两个接口 GlobalFilter,Ordered</p>
<p><strong>必须加入容器，实现接口</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200921154404.png"></p>
<p>意思：必须带有参数uname的，如果没有就过滤掉</p>
</li>
<li><p>启动测试</p>
</li>
</ol>
<h2 id="Config服务配置"><a href="#Config服务配置" class="headerlink" title="Config服务配置"></a>Config服务配置</h2><p>问题：每个微服务都需要一个配置文件,并且,如果有几个微服务都需要连接数据库，那么就需要配4次数据库相关配置,并且当数据库发生改动,那么需要同时修改4个微服务的配置文件才可以</p>
<p><strong>概念</strong>：为微服务架构中的微服务提供集中化外部配置支持，配置服务器为各个不同的微服务应用的所有环境提供了中心化的外部配置</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200921155642.png"></p>
<p>分为服务端和客户端。</p>
<p>服务端就是分布式配置中心，是一个独立的微服务应用，默认采用git存储配置信息</p>
<p>客户端是启动时在配置中心获取加载配置信息</p>
<p><strong>作用</strong>：</p>
<ol>
<li>集中管理配置</li>
<li>动态化配置更新</li>
<li>不同环境不同配置</li>
<li>将配置信息以Rest接口的形式暴露（通过controller获取配置信息）</li>
</ol>
<h3 id="使用配置中心（服务端）"><a href="#使用配置中心（服务端）" class="headerlink" title="使用配置中心（服务端）"></a>使用配置中心（服务端）</h3><ol>
<li><p>使用github作为配置中心的仓库</p>
<p><strong>初始化git环境:</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200921162559.png"></p>
</li>
<li><p>新建config服务端模块</p>
<ol>
<li>pom(引入config-server依赖)</li>
<li>yml配置文件</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200921162617.png"></p>
<ol start="3">
<li><p>主启动（@EnableConfigServer开启配置中心服务端）</p>
</li>
<li><p>修改本地hosts</p>
<p>为了输入url时localhost直接等于config-3344.com</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200921162733.png"></p>
</li>
<li><p>测试</p>
<p>启动3344    (要先启动eureka)</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200921162928.png"></p>
</li>
</ol>
</li>
</ol>
<p><strong>读取配置文件的规则</strong></p>
<ol>
<li></li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200921192655.png"></p>
<ol start="2">
<li></li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200921192848.png"></p>
<h3 id="使用配置中心（客户端）"><a href="#使用配置中心（客户端）" class="headerlink" title="使用配置中心（客户端）"></a>使用配置中心（客户端）</h3><ol>
<li><p>创建config客户端项目</p>
<p>cloud-config-client-3355</p>
</li>
<li><p>pom(引入config依赖)</p>
</li>
<li><p>yml配置文件</p>
<p>注意：这个配置文件就不是application.yml，bootstrap.yml</p>
<p>这个配置文件的作用是,先到配置中心加载配置,然后加载到application.yml中</p>
<p>因为bootstrap具有高优先级，保证不会被本地配置覆盖，负责从外部源加载配置文件，两个上下文实现共享</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200921195513.png"></p>
</li>
<li><p>主启动类（@EnableEurekaClient，这里没有配置客户端的注解）</p>
</li>
<li><p>controller</p>
<p>这就是上面提到的rest风格将配置对外暴露</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200921195502.png"></p>
<p>如果客户端运行正常,就会读取到github上配置文件的属性<code>config.info</code>的值</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200921195523.png"></p>
</li>
<li><p>测试：</p>
<p>启动3344，3355</p>
<p>访问3355的 /configInfo</p>
</li>
</ol>
<p>问题：如果配置修改，3344仍然能获得最新配置，但是3355却不能动态刷新</p>
<h3 id="实现动态刷新"><a href="#实现动态刷新" class="headerlink" title="实现动态刷新"></a>实现动态刷新</h3><ol>
<li><p>修改3355，增加pom依赖actuator监控</p>
</li>
<li><p>修改配置文件，增加一个配置</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200921201235.png"></p>
</li>
<li><p>修改controller（@RefreshScope）</p>
</li>
<li><p>需要<strong>外部</strong>发送post请求通知3355</p>
<p><code>curl -X POST "http://localhost:3355/actuator/refresh"</code></p>
</li>
<li><p>刷新测试是否更换为最新配置</p>
</li>
</ol>
<p>问题：如果由多个客户端，每个都需要通知会很麻烦，所以需要广播，这就引出了Bus消息总线</p>
<h2 id="SpringCloud-Bus-消息总线"><a href="#SpringCloud-Bus-消息总线" class="headerlink" title="SpringCloud Bus 消息总线"></a>SpringCloud Bus 消息总线</h2><p>它是将分布式系统的节点与轻量级消息系统链接起来的框架</p>
<p>目前支持RabbitMQ和Kafka</p>
<p><strong>设计思想</strong>：</p>
<ol>
<li><p>消息发给客户端，它能让其在其它客户端间传播</p>
</li>
<li><p>也可以将消息发给config配置中心，一次性广播给其他客户端</p>
</li>
</ol>
<ul>
<li>发给配置中心更合理，第一种破坏了业务模块职责的单一性，破坏了服务个节点的对等性</li>
</ul>
<p><strong>概念</strong>：在微服务架构中，通常会使用消息代理构建一个共有的主题，让所有微服务实例都订阅，该主题产生的消息也会被监听和消费，所以它为消息总线。</p>
<p><strong>原理</strong>：configClient实例都监听同一个主题，当一个服务刷新数据，它会把消息放在主题中，其他实例就能得到通知，然后更新自身的配置</p>
<h3 id="使用-4"><a href="#使用-4" class="headerlink" title="使用"></a>使用</h3><ol>
<li><p><strong>配置RabbitMQ环境</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200921210902.png"></p>
</li>
<li><p>为演示多个通知，多创建一个配置中心客户端</p>
<p>==<strong>复制3355即可,创建为3366</strong>==</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200921205750.png"></p>
<p>全部复制3355的即可</p>
</li>
<li><p>使用Bus实现全局广播</p>
<ul>
<li>配置3344(配置中心服务端)</li>
</ul>
<ol>
<li><p>修改yml配置文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200921205854.png"></p>
</li>
<li><p>添加pom</p>
<p>springboot的监控组件actuator,和消息总线整合rabbitmq:bus-amqp</p>
</li>
</ol>
<ul>
<li>修改3355（配置中心的客户端1）</li>
</ul>
<ol>
<li><p>增加pom</p>
<p>springboot的监控组件actuator,和消息总线整合rabbitmq:bus-amqp</p>
</li>
<li><p>修改yml文件（注意客户端的配置文件都交bootstrap）</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200921210757.png"></p>
</li>
</ol>
<ul>
<li>修改3366（配置中心的客户端2）</li>
</ul>
<ol>
<li>和上面的步骤一样</li>
</ol>
<ul>
<li><p>测试：</p>
<p>启动7001（注册中心），3344（配置中心服务器），3355，3366（配置中心客户端）</p>
<p>修改github的配置文件</p>
<p><strong>因为我们采用的是发送通知给服务器，再广播给客户端的方式，所以要给3344发消息</strong></p>
<p><code>curl -X POST "http://localhost:3344/actuator/bus-refresh"</code></p>
</li>
</ul>
<p><strong>原理</strong>：所有客户端都监听了一个rabbitMq的topic,我们将信息放入这个topic,所有客户端都可以送到,从而实时更新</p>
</li>
</ol>
<h3 id="配置定点通知"><a href="#配置定点通知" class="headerlink" title="配置定点通知"></a>配置定点通知</h3><p>只通知部分服务，其他服务不受影响</p>
<p><code>http://localhost:3344/actuator/bus-refresh/微服务名:端口号</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200921212048.png"></p>
<h2 id="Spring-Cloud-Stream消息驱动"><a href="#Spring-Cloud-Stream消息驱动" class="headerlink" title="Spring Cloud Stream消息驱动"></a>Spring Cloud Stream消息驱动</h2><p>问题：一个项目中可能有后端–&gt;大数据，如果后端用的是RabbitMq，大数据用的是kafka，就会导致经常切换，影响使用，学习负担重</p>
<p><strong>Spring Cloud Stream就类似jpa,屏蔽底层消息中间件的差异（比如kafka有topic，rabbitMq有exchange）,降低切换成本，统一消息编程模型，程序员主要操作Spring Cloud Stream即可</strong>，不需要管底层是kafka还是rabbitMq</p>
<p>应用程序通过**inputs(生产者)，outputs(消费者)**与stream中的binder对象交互，我们主要操作binder对象与底层mq交互即可。</p>
<ul>
<li><p>如何屏蔽底层差异？</p>
<p>由于不同的消息中间件实现细节有较大差异，定义的绑定器作为中间层，实现了应用程序与消息中间件之间的隔离，通过程序暴露统一的channel通道，让应用程序不再需要与消息中间件交互</p>
</li>
</ul>
<p><strong>业务流程</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200922113702.png"></p>
<p>source用于获取数据(要发送到mq的数据)<br>channel类似SpringCloudStream中的中间件,用于存放source接收到的数据,或者是存放binder拉取的数据    </p>
<p><strong>常用api和注解</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200922114245.png"></p>
<h3 id="使用SpringCloudStream"><a href="#使用SpringCloudStream" class="headerlink" title="使用SpringCloudStream"></a>使用SpringCloudStream</h3><p>创建3个模块，1个生产者，2个消费者</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200922164520.png"></p>
<h4 id="生产者创建"><a href="#生产者创建" class="headerlink" title="生产者创建"></a>生产者创建</h4><ol>
<li><p>pom(stream-rabbit)</p>
</li>
<li><p>yml配置文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200922164755.png"></p>
<p>设置stream中rabbitmq配置，之后绑定这个配置</p>
</li>
<li><p>主启动</p>
</li>
<li><p>service和实现类</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200922165101.png"></p>
<p><strong>这里,就会调用send方法,将消息发送给channel,</strong></p>
<p><strong>然后channel通过上述的配置文件信息将消费发送给binder,然后发送到rabbitmq中</strong></p>
</li>
<li><p>controller</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200922165246.png"></p>
</li>
<li><p>测试：</p>
<p><strong>启动rabbitmq</strong></p>
<p><strong>启动7001,8801</strong></p>
<p>打开rabbitmq的web界面，看到创建出来的管道Exchange（在kafka里叫做主题topic）,就是我们配置文件中配置的exchange</p>
<p><strong>访问8801的/sendMessage</strong></p>
<p>看到消息已经发送到mq中</p>
</li>
</ol>
<h4 id="消费者创建"><a href="#消费者创建" class="headerlink" title="消费者创建"></a>消费者创建</h4><ol>
<li><p>pom文件（stream-rabbit）</p>
</li>
<li><p>yml配置文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200922170845.png"></p>
</li>
<li><p>主启动类</p>
</li>
<li><p>业务类（消费数据）</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200922170910.png"></p>
<p><strong>生产者发送消息时,使用send方法发送,send方法发送的是一个个Message,里面封装了数据</strong></p>
<p>所以接收时也要使用Message<string>来接收</string></p>
</li>
<li><p>测试</p>
<p>启动7001，8801，8802</p>
<p><strong>使用生产者生产消息</strong>，消费者已经接收到消息</p>
</li>
</ol>
<h4 id="创建消费者2"><a href="#创建消费者2" class="headerlink" title="创建消费者2"></a>创建消费者2</h4><p>创建8003，和8002一摸一样，只是端口号不同，为了演示重复消费等问题</p>
<p>问题：重复消费，当生产者生产一条消息，8002/8003都消费到了同一条数据</p>
<p>原因：<strong>没有分组，不同组是可以重复消费的，同一个组中的多个消费者是竞争关系，能保证消息只会被其中一个消费者消费一次</strong></p>
<h4 id="自定义分组（解决重复消费）"><a href="#自定义分组（解决重复消费）" class="headerlink" title="自定义分组（解决重复消费）"></a>自定义分组（解决重复消费）</h4><p><strong>修改8802,8803的配置文件</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200922172928.png"></p>
<p>将8802，8803都分到A组</p>
<p>重启这两个消费者，生产消息，会发现没有重复消费</p>
<p><strong>持久化问题</strong>：</p>
<p>当服务（消费者）挂掉，怎么消费生产者生产还没有消费的数据？</p>
<p>结论：<strong>只要加上group分组，当下次重启之后，就会自动获取未消费的消息继续消费</strong></p>
<h2 id="Spring-Cloud-Sleuth链路追踪"><a href="#Spring-Cloud-Sleuth链路追踪" class="headerlink" title="Spring Cloud Sleuth链路追踪"></a>Spring Cloud Sleuth链路追踪</h2><p>问题：在微服务框架中，客户端发送的请求在后端系统可能会经过很多服务节点，我们可以通过链路追踪查看都调用了哪些服务</p>
<p>sleuth就是用于追踪每个请求的整体链路</p>
<p><strong>原理</strong>：</p>
<p>Trace ID：一条链路的唯一标识</p>
<p>Span ID：一次请求的唯一标识</p>
<p>Parent ID：上一次请求的唯一标识</p>
<p>在经过一次请求时，sleuth会记录下各种ID，最后连接起来</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200922175112.png"></p>
<h3 id="使用-5"><a href="#使用-5" class="headerlink" title="使用"></a>使用</h3><ol>
<li><p>安装zipkin（图形化展示链路）</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200922174950.png"></p>
<ol>
<li>运行jar包 <code>java -jar xxxx.jar</code></li>
<li><strong>然后就可以访问web界面,  默认zipkin监听的端口是9411</strong><code>localhost:9411/zipkin/</code></li>
</ol>
</li>
<li><p>使用sleuth</p>
<ol>
<li><p>修改8001的pom（zipkin）</p>
<p>这个包虽然叫zipkin但是,里面包含了zpikin与sleuth</p>
</li>
<li><p>修改yml配置文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200922195310.png"></p>
</li>
<li><p>修改80的pom（一样）</p>
</li>
<li><p>修改yml配置文件（一样）</p>
</li>
</ol>
</li>
<li><p>测试</p>
<p>启动7001,8001,80</p>
<p><code>localhost:9411/zipkin/</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200922195438.png"></p>
</li>
</ol>
<h1 id="SpringCloud-Alibaba"><a href="#SpringCloud-Alibaba" class="headerlink" title="SpringCloud Alibaba"></a>SpringCloud Alibaba</h1><p><strong>支持的功能</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200922201639.png"></p>
<h2 id="Nacos注册中心-配置中心"><a href="#Nacos注册中心-配置中心" class="headerlink" title="Nacos注册中心+配置中心"></a>Nacos注册中心+配置中心</h2><p>Nacos=Eureka+config+bus</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>需要java8  和 Maven</p>
<ol>
<li><p>到github上下载安装包</p>
<p>解压安装包</p>
</li>
<li><p>启动Nacos<strong>（注册中心服务器）</strong></p>
<p>在bin下,进入cod</p>
<p>./startup.cmd</p>
</li>
<li><p>访问Nacos</p>
<p>Nacos默认监听8848</p>
<p>localhost:8848/nacos</p>
<p>账号密码:默认都是nacos</p>
</li>
</ol>
<h3 id="使用注册中心"><a href="#使用注册中心" class="headerlink" title="使用注册中心"></a>使用注册中心</h3><h4 id="创建服务提供者"><a href="#创建服务提供者" class="headerlink" title="创建服务提供者"></a>创建服务提供者</h4><p>注册中心服务器已经不需要我们手写，Nacos启动就是服务器</p>
<ol>
<li><p>创建服务提供者模块cloudalibaba-pay-9001</p>
</li>
<li><p>改pom</p>
<ol>
<li>父工程alibaba-dependencies</li>
<li>alibaba-nacos-discovery</li>
</ol>
</li>
<li><p>yml配置文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200922205153.png"></p>
</li>
<li><p>主启动类@EnableDiscoveryClient</p>
</li>
<li><p>controller</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200922205220.png"></p>
</li>
<li><p>测试</p>
<p>启动nacos，9001服务提供者</p>
<p>查看web界面，看看9001是否注册成功</p>
</li>
</ol>
<h4 id="创建服务提供者2（测试负载均衡）"><a href="#创建服务提供者2（测试负载均衡）" class="headerlink" title="创建服务提供者2（测试负载均衡）"></a>创建服务提供者2（测试负载均衡）</h4><p>直接复制上面的9001即可</p>
<h4 id="创建消费者模块"><a href="#创建消费者模块" class="headerlink" title="创建消费者模块"></a>创建消费者模块</h4><ol>
<li><p>cloudalibaba-order-83</p>
</li>
<li><p>Pom（alibaba-nacos-discovery）</p>
<p>因为内部集成了Ribbon，所以自带负载均衡功能</p>
</li>
<li><p>yml配置文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200922204802.png"></p>
</li>
<li><p>主启动类@EnableDiscoveryClient</p>
</li>
<li><p>配置类</p>
<p>因为Naocs要使用Ribbon进行负载均衡,那么就需要使用RestTemplate</p>
<p><strong>@LoadBalanced开启负载均衡</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200922204932.png"></p>
</li>
<li><p>controller</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200922205029.png"></p>
</li>
<li><p>测试</p>
<p>启动83消费者，访问9001,9002，负载均衡</p>
</li>
</ol>
<p><strong>Nacos与其他服务注册的对比</strong></p>
<p>Nacos它既可以支持CP,也可以支持AP,可以切换</p>
<p>一般来说，不需要存储服务级别的，用AP，高可用而削弱了一致性，临时实例</p>
<p>需要服务级别编辑或存储配置信息，CP是必须的，持久化实例</p>
<p>用于切换模式</p>
<p><code>curl -X PUT '$NACOS_SERVER:8848/nacos/v1/ns/operator/switches?entry=serverMode&amp;value=CP'</code></p>
<h3 id="使用配置中心"><a href="#使用配置中心" class="headerlink" title="使用配置中心"></a>使用配置中心</h3><p>在项目初始化后，要保证从配置中心进行配置拉取，拉取配置之后，才能保证下项目正常启用</p>
<h4 id="创建配置中心的客户端模块"><a href="#创建配置中心的客户端模块" class="headerlink" title="创建配置中心的客户端模块"></a>创建配置中心的客户端模块</h4><p>cloudalibaba-Nacos-config-client-3377</p>
<ol>
<li><p>pom</p>
<ol>
<li>alibaba-nacos-config</li>
<li>alibaba-nacos-discovery</li>
</ol>
</li>
<li><p>yaml配置文件</p>
<p>这里需要配置两个配置文件,application.yml和bootstrap.yml（通用配置）</p>
<p>主要是为了可以与spring clodu config无缝迁移</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200922212217.png"></p>
</li>
<li><p>主启动类@EnableDiscoveryClient</p>
</li>
<li><p>controller</p>
<p>@RefreshScope支持动态刷新</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200922230813.png"></p>
</li>
<li><p><strong>在Nacos添加配置信息</strong></p>
<p>Nacos的配置规则：</p>
<p>就是我们在客户端如何指定读取配置文件,配置文件的命名的规则</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200922231143.png"></p>
<p>prefix:</p>
<p><strong>默认就是当前服务的服务名称</strong>,也可以通过spring.cloud.necos.config.prefix配置</p>
<p>spring.profile.active：</p>
<p>就是我们在application.yml中指定的,当前是开发环境还是测试等环境，这个可以不配置,如果不配置,那么前面的 -  也会没有</p>
<p>file-extension：</p>
<p>就是当前文件的格式(后缀),目前只支持yml/yaml和properties</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200922231413.png"></p>
<p><strong>在web页面上创建配置文件</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200922231601.png"></p>
<p>Data ID：就是按照命名规则配置的名字</p>
</li>
<li><p>测试</p>
<p>重启配置文件模块客户端</p>
<p>访问controller,<code>localhost:3377/config/info</code></p>
<p>拿到配置文件的值</p>
<p><strong>这时我们已经自动开启了动态刷新，只要修改配置文件，客户端就会立即刷新，因为Nacos支持Bus总线，会自动发送命令更新所有客户端</strong></p>
</li>
</ol>
<h4 id="Nacos配置中心之分类配置"><a href="#Nacos配置中心之分类配置" class="headerlink" title="Nacos配置中心之分类配置:"></a>Nacos配置中心之分类配置:</h4><p>问题：实际开发中会为一个系统准备多个开发环境，也会有多个配置文件，为了区分读取配置文件，可以将配置进行分类读取</p>
<p>配置文件可以归为：Namespace（命名空间）+Group（组）+Data ID（开发环境）</p>
<p>默认情况：Namespace=public，Group=DEFAULT_GROUP,环境=DEFAULT</p>
<ol>
<li><p><strong>按照不同的DataId划分</strong></p>
<ol>
<li><p>在配置中心新建两个配置文件，DataID分为两个，dev,test</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200922234152.png"></p>
</li>
<li><p>通过application.yml配置文件，实现多环境读取</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200922234007.png"></p>
<p>此时,改为dev,就会读取dev的配置文件,改为test,就会读取test的配置文件</p>
<p>重启服务</p>
</li>
</ol>
</li>
<li><p><strong>按照不同的GroupID划分</strong></p>
<ol>
<li><p>直接在配置中心新建配置文件时指定组</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200922234314.png"></p>
</li>
<li><p>在客户端配置,使用指定组的配置文件</p>
<p>bootstrap+application</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200922234425.png"></p>
<p>重启服务</p>
</li>
</ol>
</li>
<li><p><strong>按照不同的namespace划分</strong></p>
<ol>
<li><p>创建新命名空间，在新命名空间中创建配置文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200922234645.png"></p>
</li>
<li><p>客户端配置使用不同名称空间:</p>
<p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200922235238.png"></p>
<p>重启服务</p>
</li>
</ol>
</li>
</ol>
<h3 id="Nacos集群和持久化配置"><a href="#Nacos集群和持久化配置" class="headerlink" title="Nacos集群和持久化配置:"></a>Nacos集群和持久化配置:</h3><p>Nacos默认有自带嵌入式数据库,derby,但是如果做集群模式的话,就不能使用自己的数据库</p>
<p>​            不然每个节点一个数据库,那么数据就不统一了,需要使用外部的mysql</p>
<p>Nacos采用了集中式存储方式来支持集群化部署，目前只支持MySQL的存储</p>
<ol>
<li><p>切换mysql数据库:</p>
<p>将默认的derby数据库切换为mysql数据库，<strong>要求数据库（5.6+）</strong></p>
</li>
<li><p>找到Nacos安装目录下的sql脚本，在Mysql中使用该脚本nacos-mysql.sql</p>
</li>
<li><p>修改Nacos安装目录下的安排application.properties,添加:</p>
<pre class=" language-properties"><code class="language-properties"><span class="token attr-name">spring.datasource.platform</span><span class="token punctuation">=</span><span class="token attr-value">mysql</span>
 
<span class="token attr-name">db.num</span><span class="token punctuation">=</span><span class="token attr-value">1</span>
<span class="token attr-name">db.url.0</span><span class="token punctuation">=</span><span class="token attr-value">jdbc:mysql://localhost:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true</span>
<span class="token attr-name">db.user</span><span class="token punctuation">=</span><span class="token attr-value">root    #可变</span>
<span class="token attr-name">db.password</span><span class="token punctuation">=</span><span class="token attr-value">123456    #可变</span>
</code></pre>
</li>
<li><p>此时可以重启nacos,那么就会改为使用我们自己的mysql</p>
<p>数据消失，证明已经切换成功</p>
</li>
</ol>
<h3 id="Linux上配置Nacos集群-Mysql数据库"><a href="#Linux上配置Nacos集群-Mysql数据库" class="headerlink" title="Linux上配置Nacos集群+Mysql数据库"></a>Linux上配置Nacos集群+Mysql数据库</h3><p><img src="https://cdn.jsdelivr.net/gh/fenghen0918/jm-imgs/markdown/20200923083139.png"></p>
<p><strong>需要1个nginx，3个Nacos,1个Mysql</strong></p>
<ol>
<li><p>下载安装Nacos的Linux版安装包</p>
</li>
<li><p>进入安装目录,现在执行自带的sql文件(<strong>配置Mysql</strong>)</p>
<p>进入mysql,执行sql文件</p>
</li>
<li><p>修改配置文件,切换为我们的mysql(<strong>配置Nacos</stron